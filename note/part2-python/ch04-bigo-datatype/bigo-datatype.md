# Part 2. 파이썬

## 4장 - 빅오, 자료형

### 빅오

- 빅오; 입력값이 무한대로 향할 때 함수의 상한을 설명하는 수학적 표기 방법
- 점근적 실행 시간 표기할 때 가장 많이 사용 (입력값이 무한대를 향할 때 함수의 실행 시간 추이)
- 관심의 대상이 되는 것은 입력의 크기가 충분히 클 때
- 점근적 실행 시간 => 시간 복잡도
  - 시간 복잡도; 어떤 알고리즘을 수행하는 데 걸리는 시간을 설명하는 계산 복잡도
- 최고차항만 표기, 상수항은 무시
- 시간 복잡도 표기 시 입력값에 따른 알고리즘의 실행 시간 추이만 살펴봄
- 빅오 표기법 종류

  - O(1)
    - 상수 시간
    - ex) 해시 테이블의 조회 및 삽입
  - O(log n)
    - 로그 시간
    - ex) 이진 검색
  - O(n)
    - 선형 시간
    - 알고리즘 수행하는데 걸리는 시간 입력값에 비례
    - ex) 정렬되지 않은 리스트에서 최댓값/최솟값 찾기
  - O(nlog n)
    - 비교 기반 정렬 알고리즘은 아무리 좋아도 O(nlog n)보다 빠를 수 없음
    - 물론 입력값이 최선인 경우 비교를 건너뛰어 O(n)이 될 수 있음 ex) 팀 소트
    - ex) 병합 정렬
  - O(n^2)
    - ex) 버블 정렬
  - O(2^n)
    - ex) 피보나치 수 - 재귀
  - O(n!)
    - ex) 외판원 문제 (TSP) - 브루트 포스

- 상한과 최악
  - 상한(Upper Bound); 빅오는 상한을 의미
  - 하한(Lower Bound); 빅오메가는 하한을 의미
  - 빅세타는 평균을 나타냄
  - 학계와 달리 업계에서는 빅오와 빅세타를 하나로 합쳐서 단순하게 표현하는 경향
  - 빅오 표기법은 정확하게 쓰기에는 너무 길고 복잡한 함수를 '적당히 정확하게' <br/>
    표현하는 방법일 뿐, 최악/평균적인 경우의 시간 복잡도와는 아무런 관련 없음
  - 가장 빨리 실행될 때 => 빅오메가
  - 가장 늦게 실행될 때 => 빅오
  - 평균적으로 빅 세타
  - 빅오는 상한을 의미함
    - 상한을 너무 높게 설정하면 데이터에 대한 의미가 없음
  - 빅오 표기법은 주어진(best/worst/average) 경우의 수행 시간의 상한을 의미
- 분할 상환 분석
  - Worst case만 보는 것은 지나치게 비관적
  - Amortized Analysis
  - 최악의 경우를 여러 번에 걸쳐 골고루 나눠주는 형태로 알고리즘의 시간 복잡도 계산
- 병렬화
  - 실행 속도 높이기
  - GPU; 병렬 연산 장치
  - GPU 각각 코어는 CPU보다 훨씬 느리지만, GPU 코어는 수천여 개로 구성
  - 수십여 개의 CPU 보다 수백 배 더 많은 연산 동시 수행 가능
  - GPU는 같은 시간에 목적지에 훨씬 더 많은 짐을 나를 수 있음
    - 비행기 vs. 배
  - 근래에 딥러닝 관련하여 알고리즘 우수성 평가하는 매우 중요한 척도 중 하나

### 자료형

- 파이썬 자료형

  - 파이썬3 표준 타입 계층 구조 (3.7 기준)

    - None
    - 숫자
      - 정수형
        - 정수; int만 제공 (PEP 237, int 충분 X => 자동 long 타입 변경)
          - 임의 정밀도 지원
        - 불리언; int의 서브 클래스 (논리 자료형 내부적으로 정수값 가짐)
          - object > int > bool
      - 실수형
        - 실수
    - 집합형
      - 집합; 중복된 값을 갖지 않는 자료형 (값만 선언)
        - 입력 순서 유지 X, 중복된 값 있을 경우 하나의 값만 유지
    - 매핑

      - 딕셔너리; 키/자료형으로 구성된 복잡 자료형 (키/값 형태)

    - 시퀀스; 특정 대상의 순서 있는 나열
      - 불변; 값 변경 불가
        - 문자열; 문자의 순서 있는 나열
        - 튜플
        - 바이트
      - 가변
        - 리스트; 다양한 값들을 배열 형태의 순서 있는 나열로 구성
          - 배열의 역할 수행
          - 자유롭게 값을 추가/삭제할 수 있는 동적 배열

- 원시 타입
  - C언어는 동일한 정수형이라도 크기나 부호에 따라 다양한 원시 타입 제공
  - 파이썬; 임의 정밀도, 숫자를 단일형으로 처리 가능, 언어 매우 단순한 구조
  - 메모리에 정확하게 타입 크기만큼의 공간 할당, 공간에 값 집어넣음
  - 객체는 편리하고 다양한 기능을 제공하기 위해 일정 부분 속도와 공간 희생
  - 파이썬은 원시 타입 지원 X (파이썬 지원 타입은 객체)
- 객체
  - 파이썬은 모든 것이 객체임
    - 메모리 상에 위치한 객체 주소 얻어오는 id() 실행 결과 동일 (얕은 복사 시)
  - 불변 객체; bool, int, float, tuple, str
    - 값을 담고 있는 변수는 사실 참조일 뿐 실제 값 가지고 있는 것은 모두 불변 객체
    - 상수처럼 read-only 용도로 사용 가능
    - dict의 키나 set의 값으로 사용 가능
  - 가변 객체; list, set, dict
  - 속도

### [Note]

- 빅오; 입력값이 커질 때 알고리즘의 실행 시간(시간 복잡도)과 함께 <br/>
  공간 요구사항(공간 복잡도)이 어떻게 증가하는지 표현
- 상한과 최악은 의미가 같지 않음
- 분할 상환 분석
- 비교 기반 정렬 알고리즘; 적어도 모든 수에 대해 한 번 이상 비교
- 외판원 문제; 각 도시 방문하고 돌아오는 가장 짧은 경로 찾는 문제
- O(n^2)과 O(2^n)은 복잡도가 매우 차이남
- 시간과 공간이 Trade-off 관계 (대부분의 경우)
  - 실행 시간이 빠른 알고리즘은 공간을 많이 사용
  - 공간을 적게 차지하는 알고리즘은 실행 시간이 느림
- 로무토 파티션; 피벗을 정할 때 가장 우측을 택하는 가장 단순한 피벗 선택 방식
- 표기법과 복잡도는 관련이 없음
- 임의 정밀도; 무제한 자릿수 제공하는 정수형
  - 정수를 숫자의 배열로 간주 (자릿수 단위로 쪼개어 배열 형태로 표현)
  - 자릿수 단위로 구분한 값을 별도로 계산하여 처리
  - 계산 속도가 저하됨
  - 숫자를 단일형으로 처리할 수 있어서 매우 단순한 구조로 만들기 가능
  - 오버플로 고민할 필요 X => 잘못된 계산 오류 방지
  - 기능과 안전을 위해 속도와 맞바꿈
  - 기본 정수형인 int가 임의 정밀도 연산까지 수행
- 파이썬 컴파일러는 타입 결정을 자동으로 함 (동적 타이핑 언어)
- C나 자바는 성능에 대한 우선순위가 높은 언어
  - 좀 더 H/W에 가까운 원시 타입 별도 제공
- 파이썬은 편리한 기능 제공에 우선순위
  - 느린 속도, 많은 메모리 차지하더라도 더 다양한 기능 제공하는 객체에 관심 둠
  - 파이썬에는 원시 타입이 없음
- 파이썬 is vs. ==
  - is는 id() 값 비교하는 함수
    - None은 널로서 값 자체가 정의되어 있지 않아 ==로 비교 불가
    - is로만 비교 가능
  - ==는 값 비교 연산자
- 자료구조 vs. 자료형 vs. 추상 자료형
  - 자료구조; 데이터에 효율적으로 접근하고 조작하기 위한 데이터의 로직, 관리, 저장 구조
  - 자료형; 컴파일러 또는 인터프리터에게 프로그래머가 데이터 어떻게 사용하는지 <br/>
    알려주는 일종의 데이터 속성
    - 모든 자료의 유형
  - 추상 자료형
    - ADT
    - 자료형에 대한 수학적 모델
    - 해당 유형의 자료에 대한 연산
    - 행동만 정의할 뿐 실제 구현 방법은 명시 X
